import streamlit as st
import threading
import requests
import random
import time
import string

def generate_random_string(length=12):
    chars = string.ascii_letters + string.digits
    return ''.join(random.choices(chars, k=length))

def send_message(token, channel_id, base_message, mentions, use_random_only):
    suffix = generate_random_string()
    mention_str = ' '.join(f"<@{uid}>" for uid in mentions)
    if use_random_only:
        content = f"{suffix} {mention_str}".strip()
    else:
        content = f"{base_message} {suffix} {mention_str}".strip()

    headers = {
        "Authorization": token,
        "Content-Type": "application/json"
    }
    payload = {"content": content}

    try:
        response = requests.post(
            f"https://discord.com/api/v10/channels/{channel_id}/messages",
            headers=headers,
            json=payload
        )
        if response.ok:
            return f"[OK] {token[:10]}... sent"
        else:
            return f"[ERROR] {token[:10]}... {response.status_code}"
    except Exception as e:
        return f"[EXCEPTION] {token[:10]}... {e}"

def spam_loop(tokens, channel_ids, base_message, user_ids, mention_count, interval_ms, use_random_only, stop_event, log_fn):
    while not stop_event.is_set():
        for token in tokens:
            if stop_event.is_set():
                break
            channel_id = random.choice(channel_ids)
            mentions = random.sample(user_ids, min(mention_count, len(user_ids))) if user_ids and mention_count > 0 else []
            msg = send_message(token, channel_id, base_message, mentions, use_random_only)
            log_fn(msg)
        time.sleep(interval_ms / 1000.0)

st.set_page_config(page_title="HRVXRaider", page_icon="ðŸ’¥")
st.title("HRVXRaider (Streamlit)")

tokens_input = st.text_area("Tokens (one per line)")
channel_ids_input = st.text_area("Channel IDs (one per line)")
user_ids_input = st.text_area("User IDs (one per line, optional)")
mention_count = st.number_input("How many users to mention", min_value=0, step=1, value=1)
base_message = st.text_input("Message")
interval = st.number_input("Interval (ms)", min_value=100, value=1000)
use_random_only = st.checkbox("Use fully random message")

# Prep values
tokens = [x.strip() for x in tokens_input.splitlines() if x.strip()]
channel_ids = [x.strip() for x in channel_ids_input.splitlines() if x.strip()]
user_ids = [x.strip() for x in user_ids_input.splitlines() if x.strip()]

if "running" not in st.session_state:
    st.session_state.running = False
    st.session_state.stop_event = threading.Event()
    st.session_state.logs = []

def log_fn(msg):
    timestamp = time.strftime("%H:%M:%S")
    st.session_state.logs.append(f"[{timestamp}] {msg}")
    st.session_state.logs = st.session_state.logs[-300:]

col1, col2 = st.columns(2)
with col1:
    if not st.session_state.running and st.button("Start"):
        if not tokens or not channel_ids or (not base_message and not use_random_only):
            st.warning("Missing required input fields.")
        else:
            st.session_state.stop_event.clear()
            threading.Thread(
                target=spam_loop,
                args=(tokens, channel_ids, base_message, user_ids, mention_count, interval, use_random_only, st.session_state.stop_event, log_fn),
                daemon=True
            ).start()
            st.session_state.running = True
            log_fn("Started spamming...")
with col2:
    if st.session_state.running and st.button("Stop"):
        st.session_state.stop_event.set()
        st.session_state.running = False
        log_fn("Stopped.")

st.subheader("Logs")
st.code("\n".join(st.session_state.logs[-25:]), language="text")



